关于自定义类加载器 club.tulane.jvm.advanced.CustomClassLoader 的设计思路

<br>

<p>
CustomClassLoader 目前的作用有三点

1. 加载 xlass 文件, 这块的主要功能是映射类名与真实路径的关系, 以及解码被反转的字节

2. 加载 xar 文件包, 这块功能也是要映射出类名与真实路径关系

3. 重加载同名 xlass 文件, 这块涉及到动态加载, 需要卸载之前方法区中的 xlass 对象, 并重加载修改后的 xlass 文件为对象
</p>

<br>

下面具体讲下我的实现思路:

**第一点: 加载 xlass 文件**
<p>
要求反转字节的功能很好实现, 读取流的时候, 给所有 byte 字节做转换 (255 - x) 即可. 
但是另一个要求就很麻烦, 如何做映射关系呢?

我想到的方式就是使用静态变量做缓存, 在 findClass() 时根据传入的全额限定类名, 在缓存中查找对应文件.

那么这个映射缓存如何构造呢, 我提供了一个 addUrl() 方法, 供链接外部文件or文件夹, 这个方法会解析路径并构建缓存.
</p>

<br>

**第二点: 加载 xar 文件包**
<p>
这次的要求是解析 xar 包, 并加载其中的 xlass 文件. 照样我借助了 addUrl() 方法, 统一外部文件夹(文件)路径或是 xar 包路径的添加方式.

和普通文件夹不同的是, xar 包是压缩包, 所以解析它使用了 JarFile 这个类, 同时追溯它的路径后我觉得实现 xar 包地址映射的话, 再次加载时的方式可能太过麻烦,
这里我用了偷懒的方式, 直接将 xar 包的 xlass 文件全部写到临时文件里, 且映射缓存也指向我的临时文件.
</p>

<br>

**第三点: 重加载同名 xlass 文件**
<p>
要重加载 xlass 文件, 就需要启动新的 classLoader 去做加载动作, 否则会直接使用 JVM 方法区中已加载的类对象.
这块在 ClassLoader#loadClass 中有体现, 它会调用 findLoadedClass0() 这个本地方法得到之前此类加载器加载到的类对象.

要绕开这个限制, 有两种方式, 一是重写 loadClass, 二是 new 新的 ClassLoader 去加载.

我选择第二种, 第一种的方式本身是在保护方法区不膨胀, 且同一个 ClassLoader 只能加载一次同名类是一个非常合理的标准.

既然要 new 新的 ClassLoader 去加载, 也需要考虑旧 ClassLoader 的卸载以及它加载的类对象的卸载. 

我们知道 GC 时机是不可控制, 所以我们能做的就仅仅是去除其可达性的引用, 那么要做两件事情:

一是根据传入类名, 找到之前加载过它的类加载器, 去除其在缓存的引用.

二是根据类加载器, 去除其加载的所有类对象缓存引用.

这个卸载的具体方法是 unLoadClassLoader(), 它会根据传入类名, 卸载 CLASSLOADER_CACHE 与 CLASSNAMEMAP 这两个静态变量缓存中的相关引用.
</p>